<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beach Nourishment Profile</title>
    <script src='https://cdn.plot.ly/plotly-2.32.0.min.js'></script>
    <script>
        // MathJax configuration
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center; /* Center horizontally */
            align-items: center; /* Center vertically */
            min-height: 100vh; /* Ensure body takes full viewport height */
            box-sizing: border-box;
            font-family: sans-serif;
            /* Add some padding to prevent formula box touching edge */
            padding-bottom: 160px; /* Increased padding to avoid overlap with potentially taller formula box */
        }
        #graph-wrapper {
            position: relative; /* Needed for absolute positioning of loader */
            width: 90vw; /* 90% of viewport width */
            height: 30vw; /* 30% of viewport width */
            max-height: 60vh; /* Max height constraint */
        }
        #plotly-graph-container {
            width: 100%; /* Fill the wrapper */
            height: 100%; /* Fill the wrapper */
        }
        #formula-container {
            position: fixed; /* Position relative to the viewport */
            bottom: 10px;    /* 10px from the bottom */
            left: 10px;     /* 10px from the left */
            background-color: rgba(255, 255, 255, 0.9); /* Slightly more opaque background */
            padding: 15px; /* Increased padding */
            border: 1px solid #ccc;
            border-radius: 8px; /* Slightly larger radius */
            font-size: 18px; /* Font size 24px */
            line-height: 1.6; /* Improve line spacing for readability */
            z-index: 10; /* Ensure it's above the graph if overlapping */
            max-width: 600px; /* Optional: prevent it getting too wide */
            box-shadow: 0 4px 8px rgba(0,0,0,0.1); /* Add a subtle shadow */
        }
        /* Loading Overlay Styles */
        #loading-overlay {
            position: absolute; /* Position over the graph wrapper */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9); /* White background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20; /* Above graph, below formula box if needed */
            font-size: 18px;
            color: #333;
            transition: opacity 0.5s ease-out; /* Smooth fade out */
        }
        #loading-overlay.hidden {
            opacity: 0;
            pointer-events: none; /* Allow interaction with graph below */
        }
        /* Simple spinner */
        .spinner {
          border: 4px solid rgba(0, 0, 0, 0.1);
          width: 36px;
          height: 36px;
          border-radius: 50%;
          border-left-color: #09f; /* Blue color for spinner */
          margin-right: 10px;
          animation: spin 1s ease infinite;
        }
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="graph-wrapper">
        <div id="loading-overlay">
            <div class="spinner"></div>
            Loading graph...
        </div>
        <div id="plotly-graph-container"></div>
    </div>

    <div id="formula-container">
        <b>Formulas Used:</b>
        <div style="display:flex; gap:32px;">
            <div>
              $w = \frac{R g d^2}{C_1 \nu + \sqrt{0.75 C_2 R g d^3}}$<br>
              $A = 0.5 w^{0.44}$ (m$^{1/3}$)<br>
            </div>
            <div>
              $h_{in} = 2.28 H - 68.5 \frac{H^2}{g T^2}$<br>
              $h_{out} = 0.013 H T \sqrt{\frac{g}{d_{50} (s - 1)}}$
            </div>
        </div>
        <!-- Section for calculated values, populated by JavaScript -->
        <div id="calculated-values-section" style="margin-top: 10px; border-top: 1px solid #ddd; padding-top: 10px;">
            <!-- Content will be injected here -->
        </div>
    </div>

    <script>
        // Wait for the DOM to be fully loaded before executing script
        document.addEventListener('DOMContentLoaded', function() {
            // Get loader element
            const loader = document.getElementById('loading-overlay');
            const graphContainer = document.getElementById('plotly-graph-container');

            // --- Input data and initial calculations ---
            const pythonData = {
                d50: 0.0002, H: 0.9, T: 9, target_depth: 3.0, offset: 0,
                g: 9.81, rho_s: 2650, rho: 1025, nu: 1.0e-6, C1: 18, C2: 0.4
            };
            const R = (pythonData.rho_s - pythonData.rho) / pythonData.rho;
            const s = pythonData.rho_s / pythonData.rho;

            // Function to calculate settling velocity
            function settling_velocity(d) {
                d = Math.max(d, 1e-9);
                const numerator = R * pythonData.g * d**2;
                const denominator_sqrt_term = 0.75 * pythonData.C2 * R * pythonData.g * d**3;
                const denominator_sqrt = Math.sqrt(Math.max(denominator_sqrt_term, 0));
                const denominator = pythonData.C1 * pythonData.nu + denominator_sqrt;
                return denominator === 0 ? 0 : numerator / denominator;
            }

            const w = settling_velocity(pythonData.d50);
            const A = 0.5 * w**0.44;

            // --- Display Calculated Values on Screen ---
            const calculatedValuesSection = document.getElementById('calculated-values-section');
            calculatedValuesSection.innerHTML = `
                <b>Calculated Parameters:</b>
                <div style="font-size: 22px; line-height: 1.5;">
                    $w \\approx ${w.toExponential(3)}$ m/s<br>
                    $A \\approx ${A.toFixed(3)}$ m$^{1/3}$
                </div>
            `;
            // Tell MathJax to re-render the new LaTeX content
            if (window.MathJax && window.MathJax.typesetPromise) {
                 window.MathJax.typesetPromise([calculatedValuesSection]);
            }

            // --- Continue with profile calculations ---
            const h_in_term2 = 68.5 * (pythonData.H**2) / (pythonData.g * pythonData.T**2);
            let h_in = 2.28 * pythonData.H - h_in_term2;
            h_in = Math.max(h_in, 0);
            const h_out_sqrt_term = pythonData.g / (pythonData.d50 * (s - 1));
            const h_out_sqrt = Math.sqrt(Math.max(h_out_sqrt_term, 0));
            let h_out = 0.013 * pythonData.H * pythonData.T * h_out_sqrt;

            let y_target = 0, y_hin = 0, y_hout = 0;
            if (A > 0) {
                y_target = (Math.max(pythonData.target_depth, 0) / A)**(3/2);
                y_hin = (Math.max(h_in, 0) / A)**(3/2);
                y_hout = (Math.max(h_out, 0) / A)**(3/2);
            } else { console.error("Calculated A is non-positive."); }

            const x_target = y_target + pythonData.offset;
            const x_hin = y_hin + pythonData.offset;
            const x_hout = y_hout + pythonData.offset;

            let x_profile = []; let h_profile = []; let plot_x_max;
            if (x_hout > pythonData.offset) {
                plot_x_max = Math.max(x_hout * 1.05, pythonData.offset + 1);
                const num_points = 500;
                for (let i = 0; i < num_points; i++) {
                    const x = pythonData.offset + (plot_x_max - pythonData.offset) * i / (num_points - 1);
                    x_profile.push(x);
                    const base = Math.max(x - pythonData.offset, 0);
                    h_profile.push(A * base**(2/3));
                }
            } else {
                plot_x_max = pythonData.offset + 1;
                x_profile = [pythonData.offset, plot_x_max];
                h_profile = [0, A * (1)**(2/3)];
                console.warn("Outer closure depth occurs at or before the specified offset.");
            }

            // --- Plotly Figure Definition ---
            const trace1 = {
                x: x_profile,
                y: h_profile,
                mode: 'lines',
                name: `Equilibrium Profile: h(x) = ${A.toFixed(3)} (x-${pythonData.offset})^(2/3)`,
                line: {color: 'blue', width: 2},
                hovertemplate: 'x=%{x:.2f} m<br>h=%{y:.2f} m<extra></extra>'
            };

            const layout = {
                title: `Equilibrium Beach Profile (d50=${(pythonData.d50*1000).toFixed(1)}mm, H=${pythonData.H}m, T=${pythonData.T}s)`,
                xaxis: { title: 'Horizontal Distance, x (m)' },
                yaxis: { title: 'Depth, h (m)', autorange: 'reversed' },
                hovermode: 'closest',
                margin: { l: 50, r: 50, t: 50, b: 50 },
                shapes: [
                    { type: 'line', x0: pythonData.offset, y0: pythonData.target_depth, x1: plot_x_max, y1: pythonData.target_depth, line: { color: "Red", width: 2, dash: "dash" } },
                    { type: 'line', x0: x_target, y0: 0, x1: x_target, y1: pythonData.target_depth, line: { color: "Red", width: 1, dash: "dot" } },
                    { type: 'line', x0: x_hin, y0: 0, x1: x_hin, y1: h_in, line: { color: "Green", width: 1, dash: "dot" } },
                    { type: 'line', x0: x_hout, y0: 0, x1: x_hout, y1: h_out, line: { color: "Purple", width: 1, dash: "dot" } }
                ],
                annotations: [
                    { x: plot_x_max, y: pythonData.target_depth, text: `${pythonData.target_depth} m Depth`, showarrow: false, yshift: 10, xanchor: "right", font: { color: "Red" } },
                    { x: x_hin, y: 0, text: `x at h_in (${h_in.toFixed(2)} m)`, showarrow: true, arrowhead: 1, ax: 0, ay: -30, xanchor: "center", font: { color: "Green" } },
                    { x: x_hout, y: 0, text: `x at h_out (${h_out.toFixed(2)} m)`, showarrow: true, arrowhead: 1, ax: 0, ay: -45, xanchor: "center", font: { color: "Purple" } }
                ]
            };
            const data = [trace1];

            // Render the plot
            Plotly.newPlot(graphContainer, data, layout, {responsive: true})
                .then(function(gd) { // gd is the graphDiv
                    // Hide the loader AFTER Plotly has finished rendering
                    loader.classList.add('hidden');

                    // Trigger a resize event explicitly after plotting
                    window.requestAnimationFrame(() => {
                         Plotly.Plots.resize(gd);
                    });

                    // Delay removal slightly to allow fade-out transition
                    setTimeout(() => {
                        if (loader.parentNode) { // Check if still attached
                            loader.parentNode.removeChild(loader);
                        }
                    }, 500); // Matches CSS transition duration
                })
                .catch(function(err) {
                    // Handle potential errors during plotting
                    console.error("Plotly rendering error:", err);
                    loader.innerHTML = '<div style="color: red; text-align: center;">Error loading graph. Please check console.</div>';
                });
        }); // End of DOMContentLoaded listener
    </script>
</body>
</html>

